# JavaScript Vulnerability Patterns Reference

This document provides a reference for identifying and remediating high-impact vulnerabilities in JavaScript and Node.js applications.

## 1. Prototype Pollution

Prototype Pollution occurs when an attacker can manipulate the `__proto__` or `constructor.prototype` properties of an object, potentially leading to property injection across all objects.

### Vulnerable vs Secure Code
```javascript
// VULNERABLE: Recursive merge without sanitization
function merge(target, source) {
    for (let key in source) {
        if (typeof target[key] === 'object' && typeof source[key] === 'object') {
            merge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

// SECURE: Check for sensitive keys
function safeMerge(target, source) {
    for (let key in source) {
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') continue;
        if (typeof target[key] === 'object' && typeof source[key] === 'object') {
            safeMerge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

// SECURE: Use null-prototype objects
const safeObj = Object.create(null);
```

### Detection
**Grep:**
```bash
grep -rnE "__proto__|constructor\[|prototype\[" --include="*.js"
grep -rnE "\.merge\(|\.extend\(|\.defaultsDeep\(" --include="*.js"
```

**ast-grep:**
```yaml
# Find vulnerable object assignments
pattern: $OBJ[$KEY] = $VAL
where:
  KEY:
    regex: "__proto__|constructor|prototype"
```

### Impact
- **Remote Code Execution (RCE):** If polluted properties are used in sensitive functions (e.g., `child_process.spawn`).
- **Denial of Service (DoS):** Overwriting built-in methods like `toString`.
- **Authorization Bypass:** Injecting properties like `isAdmin: true`.

---

## 2. IDOR / BOLA (Insecure Direct Object Reference)

IDOR occurs when an application provides direct access to objects based on user-supplied input without verifying ownership.

### Vulnerable vs Secure Code
```javascript
// VULNERABLE: Direct access without ownership check
app.get('/api/user/profile/:id', async (req, res) => {
    const profile = await db.profiles.findOne({ id: req.params.id });
    res.json(profile);
});

// SECURE: Verify ownership
app.get('/api/user/profile/:id', async (req, res) => {
    const profile = await db.profiles.findOne({ 
        id: req.params.id,
        ownerId: req.user.id // Ensure user owns the resource
    });
    if (!profile) return res.status(404).send('Not found');
    res.json(profile);
});
```

### Detection
**Grep:**
```bash
grep -rn "req.params.id\|req.query.id" --include="*.js" | grep "findOne\|find\|get"
```

**ast-grep:**
```yaml
# Find DB calls using request parameters directly
pattern: $DB.findOne({ id: $REQ.params.$ID })
```

### Impact
- **Data Breach:** Unauthorized access to sensitive user data.
- **Data Manipulation:** Unauthorized modification or deletion of resources.

---

## 3. SSRF (Server-Side Request Forgery)

SSRF allows an attacker to induce the server-side application to make requests to an unintended location, often internal services.

### Vulnerable vs Secure Code
```javascript
// VULNERABLE: Direct use of user-supplied URL
app.post('/proxy', async (req, res) => {
    const response = await axios.get(req.body.url);
    res.send(response.data);
});

// SECURE: Allow-listing and validation
const ALLOWED_DOMAINS = ['api.trusted.com', 'images.trusted.com'];
app.post('/proxy', async (req, res) => {
    const userUrl = new URL(req.body.url);
    if (!ALLOWED_DOMAINS.includes(userUrl.hostname)) {
        return res.status(403).send('Forbidden');
    }
    const response = await axios.get(userUrl.href);
    res.send(response.data);
});
```

### Detection
**Grep:**
```bash
grep -rnE "axios\.(get|post|request)\(|fetch\(|http\.get\(|https\.request\(" --include="*.js"
```

**ast-grep:**
```yaml
# Find network requests with non-literal arguments
pattern: axios.get($URL)
where:
  URL:
    not:
      regex: "^['\"].*['\"]$"
```

### Impact
- **Internal Reconnaissance:** Scanning internal ports and services.
- **Cloud Metadata Theft:** Accessing `169.254.169.254` to steal IAM credentials.
- **RCE:** Interacting with internal APIs (e.g., Redis, Memcached).

---

## 4. Command Injection

Command Injection occurs when an application executes system commands with unsanitized user input.

### Vulnerable vs Secure Code
```javascript
// VULNERABLE: String concatenation in shell command
const { exec } = require('child_process');
app.get('/ping', (req, res) => {
    exec(`ping -c 4 ${req.query.host}`, (err, stdout) => {
        res.send(stdout);
    });
});

// SECURE: Use execFile with argument array (no shell)
const { execFile } = require('child_process');
app.get('/ping', (req, res) => {
    execFile('/bin/ping', ['-c', '4', req.query.host], (err, stdout) => {
        res.send(stdout);
    });
});
```

### Detection
**Grep:**
```bash
grep -rnE "child_process\.(exec|spawn|execSync|spawnSync)\(" --include="*.js"
```

**ast-grep:**
```yaml
# Find exec calls with template literals
pattern: exec(`$CMD`)
```

### Impact
- **Full System Compromise:** Attacker gains shell access to the server.
- **Data Exfiltration:** Reading sensitive files like `/etc/passwd` or `.env`.

---

## 5. NoSQL Injection

NoSQL Injection occurs when user-supplied objects are passed directly into NoSQL queries (e.g., MongoDB), allowing attackers to manipulate query logic.

### Vulnerable vs Secure Code
```javascript
// VULNERABLE: Passing object directly to query
// Attack: { "username": "admin", "password": { "$ne": "" } }
app.post('/login', async (req, res) => {
    const user = await db.users.findOne({ 
        username: req.body.username, 
        password: req.body.password 
    });
    if (user) res.send('Logged in');
});

// SECURE: Cast input to string
app.post('/login', async (req, res) => {
    const user = await db.users.findOne({ 
        username: String(req.body.username), 
        password: String(req.body.password) 
    });
    if (user) res.send('Logged in');
});
```

### Detection
**Grep:**
```bash
grep -rn "\.find({\|\.findOne({\|\.update({\|\.deleteMany({" --include="*.js"
```

**ast-grep:**
```yaml
# Find MongoDB queries using request body directly
pattern: $DB.findOne({ $KEY: req.body.$VAL })
```

### Impact
- **Authentication Bypass:** Logging in without a valid password.
- **Data Leakage:** Extracting data using operators like `$regex` or `$gt`.

---

## Framework Specific Patterns

### Express.js
- **Body Parser Limits:** Always set `limit` to prevent DoS.
  ```javascript
  app.use(express.json({ limit: '10kb' }));
  ```
- **Security Headers:** Use `helmet` to set secure HTTP headers.
  ```javascript
  const helmet = require('helmet');
  app.use(helmet());
  ```

### Next.js
- **Server Actions:** Ensure authorization checks are performed inside Server Actions.
- **API Routes:** Validate `req.method` and use CSRF protection for state-changing requests.
- **dangerouslySetInnerHTML:** Avoid using this with user-controlled data.
  ```javascript
  // VULNERABLE
  <div dangerouslySetInnerHTML={{ __html: userInput }} />
  ```
